/*
  stm32_cgen.js
  ------------------------------------------------------------
  STM32-friendly C generator for RoboControl Custom Block Builder.

  Goal:
    - Export the *program* you assembled from mini-blocks (rc_mini / rc_mini_value)
      into compile-ready C (C99) that can be pasted into STM32CubeIDE.
    - Provide a small HAL-based platform layer (rc_platform_*.c/h) that you can
      адаптувати під UART/BLE/мотор/сенсори.

  How it works (high level):
    1) For each mini-block in the builder workspace, we reconstruct the "real"
       Blockly block inside a hidden workspace (same trick as JS generator).
    2) We try to convert that block to C using two paths:
         A) Native C emitter for a set of standard blocks (if/loops/math/vars).
         B) Fallback: Blockly JS codegen -> JS-to-C "transpiler" (keeps your
            custom robot blocks working even if we don't know their types).

  You can extend mapping for your own robot blocks in RC_STM32_CGEN.blockMap.

  Exposes:
    window.RC_STM32_CGEN.generateArtifacts(builderWorkspace, { name, params })

  Author: generated by ChatGPT (GPT-5.2)
*/

(function(){
  'use strict';

  const CGEN_VERSION = 'stm32_cgen v1.0';

  // ------------------------------------------------------------
  // Utils
  // ------------------------------------------------------------
  const U = {
    esc: (s)=> String(s||'').replace(/\\/g,'\\\\').replace(/\n/g,'\\n').replace(/\r/g,'').replace(/\t/g,'\\t').replace(/"/g,'\\"'),
    jparse: (s, def)=>{ try { return JSON.parse(s); } catch(e){ return def; } },
    clamp: (v,a,b)=> Math.max(a, Math.min(b, v)),
  };

  function sanitizeCIdent(name){
    return String(name||'cb')
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9_]+/g,'_')
      .replace(/^([^a-z_])/, '_$1')
      .replace(/_+/g,'_')
      .slice(0, 48) || 'cb';
  }

  function indentLines(text, n){
    const pad = ' '.repeat(n);
    return String(text||'').split('\n').map(l=> l ? (pad + l) : l).join('\n');
  }

  function uniqName(base, used){
    let b = sanitizeCIdent(base || 'tmp');
    if (!used.has(b)) { used.add(b); return b; }
    for (let i=2;i<9999;i++){
      const k = `${b}_${i}`;
      if (!used.has(k)){ used.add(k); return k; }
    }
    return `${b}_${Math.floor(Math.random()*1e9)}`;
  }

  // Walk descendants to detect special blocks
  function hasDescendantType(block, type){
    if (!block) return false;
    try{
      if (block.type === type) return true;
      const kids = block.getDescendants ? block.getDescendants(false) : [];
      return kids.some(b=> b && b.type === type);
    }catch(e){
      return false;
    }
  }

  // ------------------------------------------------------------
  // Hidden workspace for reconstructing blocks (needs SVG init)
  // ------------------------------------------------------------
  let _hiddenDiv = null;
  let _hiddenWs = null;

  function ensureHiddenWorkspace(Blockly){
    if (_hiddenWs) return _hiddenWs;
    _hiddenDiv = document.createElement('div');
    _hiddenDiv.style.position = 'fixed';
    _hiddenDiv.style.left = '-99999px';
    _hiddenDiv.style.top = '-99999px';
    _hiddenDiv.style.width = '10px';
    _hiddenDiv.style.height = '10px';
    _hiddenDiv.style.opacity = '0';
    document.body.appendChild(_hiddenDiv);
    _hiddenWs = Blockly.inject(_hiddenDiv, {
      toolbox: '<xml></xml>',
      readOnly: false,
      scrollbars: false,
      trashcan: false,
    });
    return _hiddenWs;
  }

  function disposeHiddenWorkspace(){
    try { _hiddenWs && _hiddenWs.dispose(); } catch(e){}
    _hiddenWs = null;
    try { _hiddenDiv && _hiddenDiv.remove(); } catch(e){}
    _hiddenDiv = null;
  }

  // ------------------------------------------------------------
  // JS -> C fallback (keeps unknown/custom blocks usable)
  // ------------------------------------------------------------
  function jsToC(js){
    let c = String(js || '');
    c = c.replace(/\r\n/g,'\n');

    // async helpers
    c = c.replace(/await\s+(wait|delay)\s*\(([^\)]*)\)\s*;?/g, 'rc_delay_ms($2);');
    c = c.replace(/\b(wait|delay)\s*\(([^\)]*)\)\s*;?/g, 'rc_delay_ms($2);');

    // stop flags (builder preview used throw)
    c = c.replace(/throw\s+["'][^"']+["']\s*;?/g, 'return;');

    // window.x
    c = c.replace(/\bwindow\./g, '');

    // sensor array
    c = c.replace(/\bsensorData\s*\[/g, 'rc_sensor_data[');

    // Math
    c = c.replace(/Math\.min\s*\(/g, 'RC_MIN(');
    c = c.replace(/Math\.max\s*\(/g, 'RC_MAX(');
    c = c.replace(/Math\.abs\s*\(/g, 'RC_ABS(');
    c = c.replace(/Math\.round\s*\(/g, 'RC_ROUND(');
    c = c.replace(/Math\.floor\s*\(/g, 'RC_FLOOR(');
    c = c.replace(/Math\.ceil\s*\(/g, 'RC_CEIL(');

    // ===/!==
    c = c.replace(/===/g, '==').replace(/!==/g, '!=');

    // JS declarations -> float (fallback)
    // (we keep "for (let i=...)" workable in C99)
    c = c.replace(/^\s*(const|let)\s+/gm, 'float ');

    // parseInt(x) -> (int32_t)(x)
    c = c.replace(/parseInt\s*\(/g, '(int32_t)(');

    // Common robot API names -> rc_* hooks
    c = c.replace(/\bsendDrivePacket\s*\(/g, 'rc_send_drive_packet(');
    c = c.replace(/\bsendMotorPacket\s*\(/g, 'rc_send_motor_packet(');
    c = c.replace(/\bsetMotor\s*\(/g, 'rc_motor_set(');
    c = c.replace(/\breadSensor\s*\(/g, 'rc_sensor_read(');
    c = c.replace(/\blog\s*\(/g, 'rc_log(');

    return c.trim();
  }

  function blockToCViaJs(Blockly, block, asExpression){
    const jsGen = Blockly.JavaScript || Blockly.javascriptGenerator;
    if (!jsGen || !block) return asExpression ? '0' : '';

    // Override rc_param to output C-friendly expression (p->name)
    const oldRcParam = jsGen.forBlock && jsGen.forBlock['rc_param'];
    const ensureForBlock = ()=>{ jsGen.forBlock = jsGen.forBlock || {}; };
    ensureForBlock();

    jsGen.forBlock['rc_param'] = function(b){
      const pn = b.getFieldValue('PNAME') || 'p';
      const id = sanitizeCIdent(pn);
      return [ `p->${id}`, jsGen.ORDER_ATOMIC || 0 ];
    };

    let js = '';
    try{
      const r = (jsGen.blockToCode ? jsGen.blockToCode(block) : jsGen.blockToCode(block));
      if (Array.isArray(r)) js = r[0] || '';
      else js = r || '';
    }catch(e){
      js = '';
    }

    // restore
    if (oldRcParam) jsGen.forBlock['rc_param'] = oldRcParam;

    const c = jsToC(js);
    if (asExpression){
      // Expression blocks often return code without trailing semicolon
      // Normalize to an expression.
      // If it contains newlines, take first line.
      const line = c.split('\n').map(l=>l.trim()).filter(Boolean)[0] || '0';
      // Strip trailing ';'
      return line.replace(/;\s*$/,'');
    }
    // Statement:
    return c ? (c.endsWith('\n') ? c : (c + '\n')) : '';
  }

  // ------------------------------------------------------------
  // Native C emitter for common blocks (fast + clean)
  // ------------------------------------------------------------
  function createEmitter(){
    const usedVars = new Set();

    const ctx = {
      // inferred locals (name -> type)
      locals: new Map(),
      // temp names
      used: usedVars,
      // includes
      includes: new Set(['<stdint.h>','<stdbool.h>','<math.h>']),
      // helpers
      need: new Set(),
    };

    function declareLocal(name, type){
      const n = sanitizeCIdent(name);
      if (!ctx.locals.has(n)) ctx.locals.set(n, type || 'float');
      return n;
    }

    // Best-effort: decide expression type
    function exprType(block){
      if (!block) return 'float';
      const t = block.type;
      if (t === 'logic_boolean' || t === 'logic_compare' || t === 'logic_operation' || t === 'logic_negate') return 'bool';
      if (t === 'math_number' || t.startsWith('math_')) return 'float';
      if (t === 'variables_get') return 'float';
      if (t === 'rc_param') return 'float';
      return 'float';
    }

    function e(block, Blockly){
      if (!block) return '0';
      switch(block.type){
        case 'math_number': {
          const v = block.getFieldValue('NUM');
          const n = Number(v);
          if (Number.isFinite(n)) return String(n);
          return '0';
        }
        case 'logic_boolean': {
          const v = block.getFieldValue('BOOL');
          return (v === 'TRUE' || v === true || v === 'true') ? 'true' : 'false';
        }
        case 'variables_get': {
          const nm = block.getFieldValue('VAR') || 'var';
          const id = declareLocal(nm, 'float');
          return id;
        }
        case 'rc_param': {
          const pn = block.getFieldValue('PNAME') || 'p';
          return `p->${sanitizeCIdent(pn)}`;
        }
        case 'logic_negate': {
          const a = e(block.getInputTargetBlock('BOOL'), Blockly);
          return `(!(${a}))`;
        }
        case 'logic_compare': {
          const op = block.getFieldValue('OP') || 'EQ';
          const A = e(block.getInputTargetBlock('A'), Blockly);
          const B = e(block.getInputTargetBlock('B'), Blockly);
          const map = { EQ:'==', NEQ:'!=', LT:'<', LTE:'<=', GT:'>', GTE:'>=' };
          return `((${A}) ${map[op] || '=='} (${B}))`;
        }
        case 'logic_operation': {
          const op = block.getFieldValue('OP') || 'AND';
          const A = e(block.getInputTargetBlock('A'), Blockly);
          const B = e(block.getInputTargetBlock('B'), Blockly);
          return op === 'OR' ? `((${A}) || (${B}))` : `((${A}) && (${B}))`;
        }
        case 'math_arithmetic': {
          const op = block.getFieldValue('OP') || 'ADD';
          const A = e(block.getInputTargetBlock('A'), Blockly);
          const B = e(block.getInputTargetBlock('B'), Blockly);
          if (op === 'POWER') return `powf((float)(${A}), (float)(${B}))`;
          const map = { ADD:'+', MINUS:'-', MULTIPLY:'*', DIVIDE:'/' };
          return `((${A}) ${map[op] || '+'} (${B}))`;
        }
        case 'math_modulo': {
          const A = e(block.getInputTargetBlock('DIVIDEND'), Blockly);
          const B = e(block.getInputTargetBlock('DIVISOR'), Blockly);
          return `fmodf((float)(${A}), (float)(${B}))`;
        }
        case 'math_constrain': {
          ctx.need.add('RC_CLAMP');
          const v = e(block.getInputTargetBlock('VALUE'), Blockly);
          const lo = e(block.getInputTargetBlock('LOW'), Blockly);
          const hi = e(block.getInputTargetBlock('HIGH'), Blockly);
          return `RC_CLAMP((float)(${v}), (float)(${lo}), (float)(${hi}))`;
        }
        case 'math_single': {
          const op = block.getFieldValue('OP') || 'ABS';
          const x = e(block.getInputTargetBlock('NUM'), Blockly);
          const map = {
            ABS:`fabsf((float)(${x}))`,
            ROOT:`sqrtf((float)(${x}))`,
            LN:`logf((float)(${x}))`,
            LOG10:`log10f((float)(${x}))`,
            EXP:`expf((float)(${x}))`,
            POW10:`powf(10.0f, (float)(${x}))`,
            NEG:`(-((float)(${x})))`,
          };
          if (map[op]) return map[op];
          // trig / etc
          if (op === 'SIN') return `sinf((float)(${x}))`;
          if (op === 'COS') return `cosf((float)(${x}))`;
          if (op === 'TAN') return `tanf((float)(${x}))`;
          if (op === 'ASIN') return `asinf((float)(${x}))`;
          if (op === 'ACOS') return `acosf((float)(${x}))`;
          if (op === 'ATAN') return `atanf((float)(${x}))`;
          return `(float)(${x})`;
        }
        case 'math_round': {
          const op = block.getFieldValue('OP') || 'ROUND';
          const x = e(block.getInputTargetBlock('NUM'), Blockly);
          if (op === 'FLOOR') return `floorf((float)(${x}))`;
          if (op === 'CEIL') return `ceilf((float)(${x}))`;
          return `roundf((float)(${x}))`;
        }
        default:
          // fallback for unknown expressions
          return blockToCViaJs(Blockly, block, true);
      }
    }

    function s(block, Blockly){
      if (!block) return '';
      switch(block.type){
        case 'variables_set': {
          const nm = block.getFieldValue('VAR') || 'var';
          const id = declareLocal(nm, 'float');
          const v = e(block.getInputTargetBlock('VALUE'), Blockly);
          return `${id} = (float)(${v});\n`;
        }
        case 'math_change': {
          const nm = block.getFieldValue('VAR') || 'var';
          const id = declareLocal(nm, 'float');
          const d = e(block.getInputTargetBlock('DELTA'), Blockly);
          return `${id} += (float)(${d});\n`;
        }
        case 'controls_if': {
          let code = '';
          let n = 0;
          while (block.getInput('IF' + n)){
            const cond = e(block.getInputTargetBlock('IF' + n), Blockly);
            const body = chain(block.getInputTargetBlock('DO' + n), Blockly);
            if (n === 0) code += `if (${cond}) {\n${indentLines(body, 2)}\n}`;
            else code += ` else if (${cond}) {\n${indentLines(body, 2)}\n}`;
            n++;
          }
          if (block.getInput('ELSE')){
            const body = chain(block.getInputTargetBlock('ELSE'), Blockly);
            code += ` else {\n${indentLines(body, 2)}\n}`;
          }
          return code + '\n';
        }
        case 'controls_repeat_ext': {
          const times = e(block.getInputTargetBlock('TIMES'), Blockly);
          const i = uniqName('i', ctx.used);
          declareLocal(i, 'int32_t');
          const body = chain(block.getInputTargetBlock('DO'), Blockly);
          return `for (int32_t ${i}=0; ${i} < (int32_t)(${times}); ${i}++) {\n${indentLines(body, 2)}\n}\n`;
        }
        case 'controls_whileUntil': {
          const mode = block.getFieldValue('MODE') || 'WHILE';
          const cond = e(block.getInputTargetBlock('BOOL'), Blockly);
          const body = chain(block.getInputTargetBlock('DO'), Blockly);
          const c = mode === 'UNTIL' ? `!(${cond})` : `${cond}`;
          return `while (${c}) {\n${indentLines(body, 2)}\n}\n`;
        }
        case 'controls_for': {
          const vname = block.getFieldValue('VAR') || 'i';
          const vid = declareLocal(vname, 'int32_t');
          const from = e(block.getInputTargetBlock('FROM'), Blockly);
          const to = e(block.getInputTargetBlock('TO'), Blockly);
          const by = e(block.getInputTargetBlock('BY'), Blockly);
          const body = chain(block.getInputTargetBlock('DO'), Blockly);
          // inclusive end like Blockly
          const stepVar = uniqName('step', ctx.used);
          declareLocal(stepVar, 'int32_t');
          return `{
  int32_t ${stepVar} = (int32_t)(${by});
  for (${vid}=(int32_t)(${from}); (${stepVar}>=0) ? (${vid} <= (int32_t)(${to})) : (${vid} >= (int32_t)(${to})); ${vid} += ${stepVar}) {
${indentLines(body, 4)}
  }
}\n`;
        }
        case 'controls_flow_statements': {
          const flow = block.getFieldValue('FLOW') || 'BREAK';
          return flow === 'CONTINUE' ? 'continue;\n' : 'break;\n';
        }
        case 'text_print': {
          // print -> log
          const v = e(block.getInputTargetBlock('TEXT'), Blockly);
          ctx.need.add('RC_LOG');
          return `rc_log(${v});\n`;
        }
        default:
          // unknown statement -> JS fallback
          return blockToCViaJs(Blockly, block, false);
      }
    }

    function chain(first, Blockly){
      let out = '';
      let b = first;
      while (b){
        out += s(b, Blockly);
        b = b.getNextBlock ? b.getNextBlock() : null;
      }
      return out;
    }

    function finalizeLocals(){
      // ensure types for special locals
      // If local stored type is 'int32_t' keep, else float
      const lines = [];
      for (const [n,t] of ctx.locals.entries()){
        // avoid declaring loop index twice (we declare in for header sometimes)
        // but safe: only declare if used outside for header - we can't know. Keep only non i/tmp patterns
        if (t === 'int32_t'){
          // Declare as int32_t but initialize to 0
          lines.push(`int32_t ${n} = 0;`);
        } else if (t === 'bool'){
          lines.push(`bool ${n} = false;`);
        } else {
          lines.push(`float ${n} = 0.0f;`);
        }
      }
      return lines.join('\n');
    }

    return {
      ctx,
      expr: (b, Blockly)=> e(b, Blockly),
      stmt: (b, Blockly)=> s(b, Blockly),
      chain,
      localsDecl: finalizeLocals,
    };
  }

  // ------------------------------------------------------------
  // Artifacts (platform + block)
  // ------------------------------------------------------------
  function makePlatformArtifacts(){
    const h = `/* rc_platform.h - STM32 HAL platform hooks (edit for your robot) */\n#pragma once\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Timing\nuint32_t rc_millis(void);\nvoid rc_delay_ms(uint32_t ms);\n\n// Sensors (generic)\n// Read sensor by index (0..N-1). Return raw units you decide (e.g., mm or cm).\nint32_t rc_sensor_read(uint8_t idx);\n\n// Optional: shared sensor array (if you prefer polling in one place)\nextern volatile int32_t rc_sensor_data[8];\n\n// Motors / drive\n// Generic motor set (id 0..3). pwm can be -100..100 or -1000..1000 (your choice).\nvoid rc_motor_set(uint8_t id, int16_t pwm);\n\n// Convenience: differential drive (left/right)\nvoid rc_drive(int16_t left, int16_t right);\n\n// Packet hooks (optional): keep compatibility with JS-to-C fallback\n// Use varargs so it always compiles even if your Blockly sends 2..6 arguments.\nvoid rc_send_drive_packet(int32_t a, int32_t b, ...);\nvoid rc_send_motor_packet(int32_t a, int32_t b, ...);\n\n// Debug log (optional)\nvoid rc_log_float(float v);\n\n// Helpers\n#ifndef RC_MIN\n#define RC_MIN(a,b) (( (a) < (b) ) ? (a) : (b))\n#endif\n#ifndef RC_MAX\n#define RC_MAX(a,b) (( (a) > (b) ) ? (a) : (b))\n#endif\n#ifndef RC_ABS\n#define RC_ABS(a)   (( (a) < 0 ) ? -(a) : (a))\n#endif\n#ifndef RC_CLAMP\n#define RC_CLAMP(x,lo,hi) ( ((x) < (lo)) ? (lo) : (((x) > (hi)) ? (hi) : (x)) )\n#endif\n#ifndef RC_ROUND\n#define RC_ROUND(x) ((int32_t)((x) >= 0 ? ((x)+0.5f) : ((x)-0.5f)))\n#endif\n#ifndef RC_FLOOR\n#define RC_FLOOR(x) ((int32_t)floorf((float)(x)))\n#endif\n#ifndef RC_CEIL\n#define RC_CEIL(x) ((int32_t)ceilf((float)(x)))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n`;

    const c = `/* rc_platform_stm32_hal.c - default STM32 HAL implementation (edit!) */\n#include \"rc_platform.h\"\n\n// If you use STM32 HAL, include your main HAL header here:\n#include \"main.h\"\n\nvolatile int32_t rc_sensor_data[8] = {0};\n\nuint32_t rc_millis(void){\n  return HAL_GetTick();\n}\n\nvoid rc_delay_ms(uint32_t ms){\n  HAL_Delay(ms);\n}\n\n// Weak defaults — override in your project\n__attribute__((weak)) int32_t rc_sensor_read(uint8_t idx){\n  if (idx < 8) return rc_sensor_data[idx];\n  return 0;\n}\n\n__attribute__((weak)) void rc_motor_set(uint8_t id, int16_t pwm){\n  (void)id; (void)pwm;\n  // TODO: map id -> TIM channel, then set PWM compare\n}\n\n__attribute__((weak)) void rc_drive(int16_t left, int16_t right){\n  // Default: assume motor0=left, motor1=right\n  rc_motor_set(0, left);\n  rc_motor_set(1, right);\n}\n\n__attribute__((weak)) void rc_send_drive_packet(int32_t a, int32_t b, ...){\n  // Optional compatibility with JS-to-C fallback\n  (void)a; (void)b;\n}\n\n__attribute__((weak)) void rc_send_motor_packet(int32_t a, int32_t b, ...){\n  (void)a; (void)b;\n}\n\n__attribute__((weak)) void rc_log_float(float v){\n  (void)v;\n}\n`;

    return { platformH: h, platformC: c };
  }

  function generateArtifacts(builderWs, opts){
    const Blockly = window.Blockly;
    if (!Blockly || !builderWs) throw new Error('Blockly/workspace missing');

    const name = (opts && opts.name) ? String(opts.name) : 'custom_block';
    const params = (opts && Array.isArray(opts.params)) ? opts.params : [];

    const id = sanitizeCIdent(name);
    const guard = ('RC_CB_' + id + '_H_').toUpperCase();

    const emitter = createEmitter();

    // Create enum types for dropdown params
    const enumDecls = [];
    for (const p of params){
      if ((p.kind||'') !== 'dropdown') continue;
      const en = sanitizeCIdent(p.name || 'mode');
      const opts2 = Array.isArray(p.options) ? p.options : [];
      if (!opts2.length) continue;
      const lines = [];
      lines.push('typedef enum {');
      opts2.forEach((o,i)=>{
        const id2 = (en + '_' + sanitizeCIdent(String(o)).toUpperCase()).toUpperCase();
        lines.push(`  ${id2} = ${i},`);
      });
      lines.push(`} ${en}_t;`);
      enumDecls.push(lines.join('\n'));
    }

    const structLines = [];
    structLines.push('typedef struct {');
    if (!params.length) structLines.push('  uint8_t _unused;');
    for (const p of params){
      const pname = sanitizeCIdent(p.name || 'p');
      let t = 'float';
      if (p.kind === 'boolean') t = 'bool';
      else if (p.kind === 'text') t = 'const char*';
      else if (p.kind === 'dropdown') t = sanitizeCIdent(p.name || 'mode') + '_t';
      structLines.push(`  ${t} ${pname};`);
    }
    structLines.push(`} rc_cb_${id}_params_t;`);

    // Mini-blocks: reconstruct and emit
    const RC = window.RC_CustomBlocks || window.RC || window.CustomBlocks || window.__RC || {};
    const deser = (window.RC_CustomBlocks && window.RC_CustomBlocks._miniDeserializeTo) ? window.RC_CustomBlocks._miniDeserializeTo : (RC._miniDeserializeTo || null);
    const deser2 = window.RC? window.RC._miniDeserializeTo : null;
    const deserialize = deser || deser2 || window.RC? window.RC._miniDeserializeTo : null;

    const hiddenWs = ensureHiddenWorkspace(Blockly);

    // Get top blocks sorted top-to-bottom
    const tops = builderWs.getTopBlocks(true).slice();
    tops.sort((a,b)=> a.getRelativeToSurfaceXY().y - b.getRelativeToSurfaceXY().y);

    let body = '';

    function emitMini(mini){
      if (!mini) return '';
      const type = mini.type;
      if (type !== 'rc_mini' && type !== 'rc_mini_value'){
        // if user accidentally placed normal blocks in builder ws
        return emitter.stmt(mini, Blockly);
      }
      const wrapType = mini.getFieldValue('WRAP_TYPE');
      const state = U.jparse(mini.data || '', null);
      if (!wrapType || !state) return '/* empty mini */\n';

      // reconstruct real block
      let real = null;
      try{
        if (window.RC && window.RC._miniDeserializeTo){
          real = window.RC._miniDeserializeTo(hiddenWs, wrapType, state);
        } else if (window.RC_CustomBlocks && window.RC_CustomBlocks._miniDeserializeTo){
          real = window.RC_CustomBlocks._miniDeserializeTo(hiddenWs, wrapType, state);
        } else {
          // fallback: try load xml/json by ourselves (rare)
          hiddenWs.clear();
          if (state.kind === 'json' && Blockly.serialization?.blocks?.load){
            Blockly.serialization.blocks.load(state.payload, hiddenWs);
            real = hiddenWs.getTopBlocks(true)[0] || null;
          } else if (state.kind === 'xml'){
            const dom = Blockly.Xml.textToDom(state.payload);
            real = Blockly.Xml.domToBlock(dom, hiddenWs);
          }
        }
      }catch(e){ real = null; }

      if (!real) return `/* failed to build mini: ${U.esc(wrapType)} */\n`;

      // Prefer native emitter if block is supported. Otherwise JS fallback.
      if (type === 'rc_mini_value' || real.outputConnection){
        const expr = emitter.expr(real, Blockly);
        // If it's a pure value mini: evaluate and ignore (or log)
        return `/* value: ${expr} */\n`;
      }

      return emitter.chain(real, Blockly);
    }

    for (const t of tops){
      body += emitMini(t);
    }

    // Local declarations
    const locals = emitter.localsDecl();
    const localsBlock = locals ? (locals + '\n\n') : '';

    const header = `/* Auto-generated (${CGEN_VERSION}) */\n#ifndef ${guard}\n#define ${guard}\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#include \"rc_platform.h\"\n\n${enumDecls.length ? (enumDecls.join('\n\n') + '\n\n') : ''}${structLines.join('\n')}\n\n// Run your custom block program\nvoid rc_cb_${id}_run(const rc_cb_${id}_params_t* p);\n\n#endif // ${guard}\n`;

    const source = `/* Auto-generated (${CGEN_VERSION}) */\n#include \"rc_cb_${id}.h\"\n\nvoid rc_cb_${id}_run(const rc_cb_${id}_params_t* p){\n  (void)p;\n${indentLines(localsBlock + body, 2).trimEnd()}\n}\n`;

    const plat = makePlatformArtifacts();

    return {
      files: {
        h: `rc_cb_${id}.h`,
        c: `rc_cb_${id}.c`,
        platformH: 'rc_platform.h',
        platformC: 'rc_platform_stm32_hal.c',
      },
      h: header,
      c: source,
      platformH: plat.platformH,
      platformC: plat.platformC,
    };
  }

  // Public API
  window.RC_STM32_CGEN = {
    version: CGEN_VERSION,
    sanitizeCIdent,
    jsToC,
    generateArtifacts,
    disposeHiddenWorkspace,
    // Optional extension point: custom block map
    blockMap: {},
  };

})();
